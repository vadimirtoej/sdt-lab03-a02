# Конспект указаний, данных во время занятия

1. Разбираемся с форматом данных

Осмотр файла приводит к таким выводам:

  1. Файл состоит из слов, где слово — либо последовательность символов
     без пробелов, либо последовательность любых символов, кроме кавычек,
     в кавычках.

  2. Файл состоит из записей о линиях, станциях и переходах.  Каждый вид записи
     начинается со своего ключевого слова.  Поэтому, читав первое слово, можно
     легко разобрать запись, так как сразу понятно, какие слова идут дальше.

  3. Допустим, мы считываем переходы в цикле для каждой станции.  После того,
     как разобрано описание очередного перехода, читаем следующее слово, и это
     `"line"`.  Нужно выйти из цикла и после этого считвать описание не станции,
     а линии.  То есть последнее считанное слово должно быть доступно любой
     функции.  Либо нужна возможность посмотреть следующее слово без считывания.

Какая же получается схема разбора?

  1. Нужна функция, считывающая «слово»:

     `string read_word(istream& input);`

  Встроенный оператор считывания `std::string` покрывает вариант без кавычек.
  Второй вариант можно реализовать так: считать слово, и если оно начинается
  с кавычки, считывать (и добавлять к строке) слова, пока очередное не будет
  заканчиваться кавычкой; из строки-результата нужно удалить кавычки в начале
  и в конце.

  2. Нужны три функции, считывающие описание линии, станции, перехода:

    - считывающая линии, ей нужен доступ ко всей схеме, чтобы расширять ее;
    - считывающая станции, ей самой не нужна схема, однако
    - считывающей переход функции нужно находить станцию назначения по схеме,
      кроме того, ей нужно знать, к какой станции переход добавлять.

  3. Помимо описанных параметров, каждая функция принимает ссылку на последнее
     читанное слово, и любая функция может изменить это слово. Итого:

```
void parse_line(istream& input, string& keyword, Lines& lines);
void parse_station(istream& input, string& keyword, Lines& lines);
void parse_transit(
        istream& input, string& keyword, Lines& lines, Station& station);
```
  Считывание всей схемы также целесообразно вынести в функцию:

  `Lines parse_scheme(istream& input);`

  Каждая функция разбора считывает запись соответствующего типа (кроме первого
  слова), читает очередное слово, после чего начинает цикл до тех пор, пока
  `keyword` является соответственно `"line"` (для схемы), `"station"`
  (для линии) или `"transit"` (для станции).  У перехода дочерних записей нет,
  поэтому и цикла внутри нет.  Начало схемы никак не обозначено, поэтому
  и считывать его не нужно, но требуется инициализировать список линий.


2. Как считанные данные будут заноситься в схему?

Нужно управлять тремя видами связанных списков: линий, станций и переходов.
К счастью, требуется поддерживать лишь необходимые операции. Какие — выясняется
из механизмов работы функций.

  1. При считывании линии нужно добавить новый элемент в конец списка.
     Но может быть так, что линия уже в списке, например, если ранее была
     считана пересадка на ее станцию.  На самом деле нужна функция, которая
     либо отыщет линию в списке по имени, либо добавит новую:

     `Line* get_line(Lines& scheme, const string& name);`

  2. При считывании станции так же может оказаться, что станция уже была
     добавлена на схему; сложность еще и в том, что порядок станций на линии
     важен. Нужно сделать следующее:

    - попытаться найти станцию на линии по имени;
    - если она найдена, переместить ее в конец линии (отсоединить и добавить);
    - если не найдена, создать новую станцию и добавить ее в конец линии.

     Итого требуются функции:

```
Station* find_station(Line& line, const string& name);
void move_to_end(Line& line, Station* station);
void add_station(Line& line, const string& name);
```

  У `move_to_end()` и `add_station()` есть общая часть — присоединение станции
  в конец линии при наличии указателя (на созданную или переносимую станцию):

  `void append_station(Line& line, Station* station);`

  3. При считывании перехода нужно найти или создать линию назначения,
     затем найти или создать на ней станцию, после чего добавить переход:

```
Station* get_station(Line& line, const string& name);
void add_transit(Station& station, Station* destination);
```

3. Как проверить, что программа верно отработала?

Можно реализовать операторы вывода для наших структур:

```
ostream& operator<<(ostream& output, const Transit& transit);
ostream& operator<<(ostream& output, const Station& station);
ostream& operator<<(ostream& output, const Line& line);
```

При выводе линии выводятся ее станции, при выводе станции выводятся переходы.
Формат вывода может быть таким же, как входной.  Тогда правильно разобранная
схема при выводе будет выглядеть как исходная с точностью до перестановки
линий (так как они заносятся в список не в порядке описания — это поправимо).
